// Представьте что вы работаете в большой компании где используется модульная архитектура. Ваш коллега написал модуль с какой-то логикой (вы не знаете) и передает в вашу программу какие-то данные. Вы же пишете функцию которая считывает две переменных типа string ,  а возвращает число типа int64 которое нужно получить сложением этих строк.


// Но не было бы так все просто, ведь ваш коллега не пишет на Go, и он зол из-за того, что гоферам платят больше. Поэтому он решил подшутить над вами и подсунул вам свинью. Он придумал вставлять мусор в строки перед тем как вызывать вашу функцию.


// Поэтому предварительно вам нужно убрать из них мусор и конвертировать в числа. Под мусором имеются ввиду лишние символы и спец знаки. Разрешается использовать только определенные пакеты: fmt, strconv, unicode, strings,  bytes. Они уже импортированы, вам ничего импортировать не нужно!

// Считывать и выводить ничего не нужно!

// Ваша функция должна называться adding() !

// Считайте что функция и пакет main уже объявлены!

// Sample Input:

// %^80 hhhhh20&&&&nd
// Sample Output:

// 100

// Пакет и функция main уже объявлены!
// Импортировать ничего не нужно!
// Удачи!


func adding(str1, str2 string) int64 {
    rune1 := []rune(str1)
    rune2 := []rune(str2)
    n_str1 := ""
    n_str2 := ""

    for i := range rune1 {
        if unicode.IsDigit(rune1[i]) {
            n_str1 += string(rune1[i])
        }
    }
    for i := range rune2 {
        if unicode.IsDigit(rune2[i]) {
            n_str2 += string(rune2[i])
        }
    }

    num1, err := strconv.Atoi(n_str1)
    if err != nil {
        panic(err)
    }

    num2, err := strconv.Atoi(n_str2)
    if err != nil {
        panic(err)
    }

    return int64(num1) + int64(num2)
}